## Redis
----------------------------
### 第一记：高性能之-多路复用/单线程技术

 1. 基础：
 > Linux操作系统里，一切皆文件，因此每个process都有自己的table of **file discriptors**,指向files,sockets,devices and other os objects

 2. 并发I/O的几种solutions：
    1. 典型的socket编程是阻塞式的：即服务端准备就绪后，等待客户端发送数据过来，这样的服务端无法支持多个客户端同时访问；
    2. 为每个客户端建立一个独立的进程/线程；该方案的缺陷非常明显：虽然同一时间里的总连接数很多，但是受限于网络瓶颈，这么多的socket并不是每个都立即可读，而且终端用户活跃度比较低的情形是比较常见的。
    3. 多路复用I/O：即多个I/O复用一个线程，本质上就是将**一组sockets**对应的fd从用户态copy到kernel并且告诉kernel对每个fd期望的操作（readable/writeable）。之后使用**一个线程**调用一个阻塞方法，直到至少有一个fd达到了期望状态时，阻塞方法会被唤醒。Linux里有select,poll和epoll等函数来实现这一功能。

 3. 分析：
    - 多线程技术大部分时候都是为了更加充分地利用处理机的性能，解决了串行执行方式里单个任务对处理机利用不充分而导致处理器利用率低，系统吞吐量低的情形；
    - 为了支持多个客户端连接而开辟多个线程，如果每个线程都能跑满，且线程数量比较合理（多线程带来的收益大于线程切换的损耗），那么也是值得的；
    - 实际情况是，虽然大量的客户端建立了连接，但是任何一个时刻里实际活跃的连接数往往比总的连接数小不少，因此**处理机大部分时间都在进行频繁的应用程序里的线程切换，并且每次切换到一个下一个线程后很大概率都在空等，而真的有少数socket可读/写时，处理机可能又在别处空等，这样的情况属于将处理器资源浪费在没有意义的工作上**。
    - 多路复用I/O是将一组sfd交给内核处理，只需要一个线程值守，当任意一个fd期望状态后，值守线程去执行后续操作即可。
 
 4. 多路复用I/O的优势总结：
    - 相比于多线程方案里应用程序自己花费大量精力去主动检查大量的连接，从中发现可处理的socket，多路复用技术将检查工作交给内操作系统去做，应用程序线程只需要被动等待系统通知可处理的socket然后处理即可。从而避免了处理器资源的浪费。

----------------
### 第二记：Redis实现分布式锁

 1. Redis分布式锁的需求
 > java的类锁，对象锁以及其他高级的锁，都是JVM级别的，因此当多个服务实例（运行在多个JVM里）之间需要线程同步（最典型的就是访问临界资源时需要互斥访问）时，就需要分布式锁（Distributed Lock Manager）
 
 2. （分布式）锁的要求：
    - 排他性：不能有两个线程同时持有一同一个锁；
    - 活跃性A：如果持有锁的客户端迟迟不能释放锁（非正常地），那么需要确保锁能够回收以确保其他线程最终可以及时获取到锁；
    - 活跃性B：只要**超过半数以上**的Redis实例健康，那么客户端总能申请和释放锁

 3. 单Redis实例如何正确实现DLM
    - 活跃性A：设置锁的过期时间以**避免DeadLock**；
    - 避免过期后释放：未能在锁自动过期前释放锁的客户端，可能过了很久会来释放该锁，而该锁可能由别的线程持有，因此每个客户端获取到锁后都要设置一个unique的value（譬如**UUID+ThreadId**），释放锁时通过value校验来确保不会误删

 4. failover-based的DLM实现无法提供强排他性：
    > 原因在于Redis集群的复制是异步的，如果在从master获到的锁还未释放且master没来得及将锁同步到slave就宕机了，slave随后升级为master，其他线程就可以获取到锁了，排他性就无法得到保障。当然了，**如果系统里不要求强排他性，那么这种方案是可行的**。

 5. RedLock算法（使用N个不存在主从关系的独立的Redis实例）
 
    1.步骤：（获取：从一个实例里拿到，申请到：从半数以上实例里获取到并且有效时间为正数）
        1. 获取当前时间T1（毫秒级）；
        2. 从N个实例中依次尝试获取锁，并且一旦向某个实例获取锁超时（timeout远小于锁的过期时间TTL），那么立即去向下一个redis实例获取。直到从半数以上的实例获取到了锁T2；
        3. 客户端计算获取这些锁所花费的时间T2-T1，TTL-(T2-T1)就是客户端锁的有效时间；
        4. 如果客户端未能从半数以上的redis实例里获取到锁或者锁的有效时间为负数，那么认为锁申请失败，并且释放已经获取的锁。
        
    2.安全性分析：
        1.锁是依次从每个实例里获取来的，因此每个实例上锁的过期时间其实是不一样的，但是客户端认为的锁的有有效时间是不会晚于最先过期（获取到的第一个锁所在的redis实例）锁的过期时间的，因此，在这段时间里，不会有其他线程申请到锁；
        2.时间误差相比锁的有效时间是比较小的

    3.竞争下可用性保证：申请锁失败后重试时间是大于获取到半数以上锁的时间的，避免发生脑裂；
    
    4.性能分析：为了加快解锁和加锁，客户端采取多路发送的方式，减少通信延迟
    
    5.故障恢复：
        1.什么也不做：重启后的redis实例里失去了锁的key，别的客户端就有可能同时获取到锁
        2.持久化：能够保证重启后依然安全，但是断电这种方式下持久化也不安全
        3.延迟重启：redis实例重启后一整个锁生命周期内不得参与DLM服务，这样可以不采用持久化也能保证安全性
        
    6.锁续约提升安全性：锁过期了，业务还未结束，那么可以申请锁续约。但是锁的续约是受控的，以确保key的可用性。
    
    7.应用程序层面优化：发生竞争的多个线程之间应该加入了一个较小的偏移值，以避免集中访问。

--------------

### Redis缓存和RDS一致性方案
#### 读操作
    > 缓存命中则只读取缓存，缓存未命中则读取RDS后放入缓存
    
#### 写操作

 1. 接近最终一致性追求-双删：
    - 删除cache而不是更新cache：多个线程并发更新RDS和cached的顺序是不可知的，难以确保最终一致性；
    - 双删：更新RDS前删除key（避免后删因为故障未能发生），更新RDS后过一段时间再次删除（RDS操作比cache慢，前删后可能立马就有其他线程将旧值再次加入了cache），这样就提高了最终一致的概率；

 2. 近乎完美最终一致性-binlog：
    - alibaba canal 

 3. 在可接受的范围里，不必追求强一致性，cache的目标是提升效率！
