## Redis
----------------------------
### 多路复用/单线程技术：

 1. 基础：
 > Linux操作系统里，一切皆文件，因此每个process都有自己的table of **file discriptors**,指向files,sockets,devices and other os objects

 2. 并发I/O的几种solutions：
    1. 典型的socket编程是阻塞式的：即服务端准备就绪后，等待客户端发送数据过来，这样的服务端无法支持多个客户端同时访问；
    2. 为每个客户端建立一个独立的进程/线程；该方案的缺陷非常明显：虽然同一时间里的总连接数很多，但是受限于网络瓶颈，这么多的socket并不是每个都立即可读，而且终端用户活跃度比较低的情形是比较常见的。
    3. 多路复用I/O：即多个I/O复用一个线程，本质上就是将**一组sockets**对应的fd从用户态copy到kernel并且告诉kernel对每个fd期望的操作（readable/writeable）。之后使用**一个线程**调用一个阻塞方法，直到至少有一个fd达到了期望状态时，阻塞方法会被唤醒。Linux里有select,poll和epoll等函数来实现这一功能。

 3. 分析：
    - 多线程技术大部分时候都是为了更加充分地利用处理机的性能，解决了串行执行方式里单个任务对处理机利用不充分而导致处理器利用率低，系统吞吐量低的情形；
    - 为了支持多个客户端连接而开辟多个线程，如果每个线程都能跑满，且线程数量比较合理（多线程带来的收益大于线程切换的损耗），那么也是值得的；
    - 实际情况是，虽然大量的客户端建立了连接，但是任何一个时刻里实际活跃的连接数往往比总的连接数小不少，因此**处理机大部分时间都在进行频繁的应用程序里的线程切换，并且每次切换到一个下一个线程后很大概率都在空等，而真的有少数socket可读/写时，处理机可能又在别处空等，这样的情况属于将处理器资源浪费在没有意义的工作上**。
    - 多路复用I/O是将一组sfd交给内核处理，只需要一个线程值守，当任意一个fd期望状态后，值守线程去执行后续操作即可。
 
 4. 多路复用I/O的优势总结：
    - 相比于多线程方案里应用程序自己花费大量精力去主动检查大量的连接，从中发现可处理的socket，多路复用技术将检查工作交给内操作系统去做，应用程序线程只需要被动等待系统通知可处理的socket然后处理即可。从而避免了处理器资源的浪费。
        
    
    